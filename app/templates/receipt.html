<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Разделение чека</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        padding: 20px;
        margin: 0;
        /* Добавляем лёгкий градиент для создания более приятного фона */
        background: linear-gradient(180deg, #f9f9fb 0%, #f3f5fa 100%);
        color: #202020;
      }
      h1 {
        font-size: 24px;
        margin-bottom: 20px;
        text-align: center;
        font-weight: 600;
        color: #0b5394;
      }
      /* Контейнер для списка позиций */
      #list {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .item {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 14px 16px;
        background-color: #ffffff;
        border-radius: 12px;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        transition: background-color 0.2s ease, box-shadow 0.2s ease;
        cursor: pointer;
      }
      .item:hover {
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.08);
      }
      .item.selected {
        background-color: #eaf5ff;
      }
      .item span {
        font-size: 16px;
      }
      .controls {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      .controls input[type=number] {
        width: 55px;
        padding: 4px;
        font-size: 14px;
        border: 1px solid #d6e0ef;
        border-radius: 6px;
        background-color: #f8fafd;
      }
      .controls button {
        width: 34px;
        height: 34px;
        font-size: 18px;
        line-height: 1;
        padding: 0;
        border: 1px solid #d6e0ef;
        background-color: #f1f6fc;
        cursor: pointer;
        border-radius: 6px;
        transition: background-color 0.2s ease, box-shadow 0.2s ease;
      }
      .controls button:hover {
        background-color: #e4eef9;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.08);
      }
      /* Стили для кнопки «Поровну» */
      .equal-btn {
        flex-shrink: 0;
        padding: 0 10px;
        height: 34px;
        font-size: 14px;
        background-color: #fff2d6;
        color: #c27016;
        border: 1px solid #f3cda7;
        border-radius: 6px;
        cursor: pointer;
        transition: background-color 0.2s ease, box-shadow 0.2s ease;
      }
      .equal-btn.active {
        background-color: #ffe7bf;
        color: #a25a0e;
        border-color: #eac297;
      }
      .equal-btn:hover {
        background-color: #fce0b0;
      }
      .item.equal-share {
        background-color: #fff8e6;
      }
      button {
        margin-top: 24px;
        width: 100%;
        padding: 14px 0;
        font-size: 16px;
        font-weight: 500;
        background-color: #2f80ed;
        color: #fff;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        transition: background-color 0.2s ease, box-shadow 0.2s ease;
      }
      button:hover {
        background-color: #1366d6;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
    </style>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
  </head>
  <body>
    <h1>Выберите позиции, которые вы покупали</h1>
    <div id="list"></div>
    <!-- Блок с итоговой информацией о выборе -->
    <div id="summary" style="margin-top: 12px; font-weight: bold; text-align: center;"></div>
    <button id="submit">Отправить</button>
    <script>
      /*
       * Мини‑приложение для выбора позиций.
       *
       * В приватных чатах список позиций передаётся сервером через глобальную
       * переменную window.POSITIONS. В групповых чатах мини‑приложение
       * запускается через deep‑link с параметром startapp=group_<id>.
       * На клиенте мы извлекаем group ID из Telegram.WebApp.initDataUnsafe.start_param
       * и запрашиваем список позиций через API /webapp/api/positions.
       */

      // Получаем доступ к WebApp API.
      const tg = Telegram.WebApp;

      /**
       * Извлекает идентификатор группы из параметра start_param.
       * Возвращает строку groupId или null, если параметр отсутствует.
       */
      function extractGroupId() {
        try {
          const initData = tg.initDataUnsafe || {};
          let p = initData.start_param;
          if (!p) return null;
          // Сравниваем префикс group_
          if (typeof p === 'string' && p.startsWith('group_')) {
            return p.substring('group_'.length);
          }
          return p;
        } catch (e) {
          console.warn('Cannot parse start_param', e);
          return null;
        }
      }

      /**
       * Загружает список позиций. Если глобальная переменная POSITIONS
       * уже содержит массив позиций (для приватных чатов), возвращает его.
       * В противном случае извлекает groupId и запрашивает данные с сервера.
       */
      async function getPositions() {
        if (Array.isArray(window.POSITIONS) && window.POSITIONS.length > 0) {
          return window.POSITIONS;
        }
        const groupId = extractGroupId();
        if (!groupId) {
          return [];
        }
        try {
          const response = await fetch(`/webapp/api/positions?group_id=${encodeURIComponent(groupId)}`);
          if (!response.ok) {
            return [];
          }
          const data = await response.json();
          if (Array.isArray(data)) return data;
          return [];
        } catch (err) {
          console.error('Error fetching positions', err);
          return [];
        }
      }

      // Функция для пересчёта суммы и количества выбранных позиций.
      function updateSummary(selectedQuantities, positions, summaryEl) {
        let total = 0;
        let count = 0;
        Object.keys(selectedQuantities).forEach((idx) => {
          const qtySelected = parseFloat(selectedQuantities[idx]) || 0;
          if (qtySelected > 0) {
            const p = positions[idx];
            const price = parseFloat(p.price) || 0;
            total += qtySelected * price;
            count += qtySelected;
          }
        });
        // Количество позиций, отмеченных как «поровну» (equalSelections хранится в глобальной области)
        let equalCount = 0;
        try {
          if (window.equalSelections) {
            equalCount = Object.keys(window.equalSelections).length;
          }
        } catch (e) {
          equalCount = 0;
        }
        if (count === 0 && equalCount === 0) {
          summaryEl.textContent = 'Ничего не выбрано';
          return;
        }
        // Формируем строку с количеством выбранных позиций
        const countStr = count > 0 ? `${count} ${count === 1 ? 'позиция' : (count < 5 ? 'позиции' : 'позиций')}` : '';
        const totalStr = count > 0 ? `на сумму ${total.toFixed(2)}₽` : '';
        const equalStr = equalCount > 0 ? `${equalCount} ${equalCount === 1 ? 'позиция' : (equalCount < 5 ? 'позиции' : 'позиций')} поровну` : '';
        // Соединяем части. Используем запятую, если присутствуют несколько частей.
        const parts = [];
        if (countStr) parts.push(countStr + (totalStr ? ' ' + totalStr : ''));
        if (equalStr) parts.push(equalStr);
        summaryEl.textContent = 'Выбрано ' + parts.join(', ');
      }

      // Асинхронная инициализация.
      (async function init() {
        const positions = await getPositions();
        const listEl = document.getElementById('list');
        const summaryEl = document.getElementById('summary');
        const selectedQuantities = {};
        // Храним позиции, отмеченные как «поровну». Ключ — индекс позиции,
        // значение true. Эти позиции будут переданы в бэкэнд с
        // отрицательным количеством.
        const equalSelections = {};
        // Делаем equalSelections доступным глобально, чтобы updateSummary мог получить количество
        window.equalSelections = equalSelections;
        // Заполняем список позиций
        positions.forEach((item, idx) => {
          const el = document.createElement('div');
          el.className = 'item';
          // Левая часть: название, количество и цена
          const infoContainer = document.createElement('div');
          infoContainer.style.display = 'flex';
          infoContainer.style.flexDirection = 'column';
          infoContainer.style.flex = '1';
          const nameSpan = document.createElement('span');
          nameSpan.textContent = item.name;
          const qtyPriceSpan = document.createElement('span');
          qtyPriceSpan.style.fontSize = '14px';
          qtyPriceSpan.style.color = '#666';
          qtyPriceSpan.textContent = `${item.quantity} × ${item.price}₽`;
          infoContainer.appendChild(nameSpan);
          infoContainer.appendChild(qtyPriceSpan);
          el.appendChild(infoContainer);
          // Правая часть: кнопки +/‑ и поле ввода
          const controls = document.createElement('div');
          controls.className = 'controls';
          const maxQty = parseFloat(item.quantity) || 1;
          const minusBtn = document.createElement('button');
          minusBtn.type = 'button';
          minusBtn.textContent = '–';
          const input = document.createElement('input');
          input.type = 'number';
          input.min = '0';
          input.max = String(maxQty);
          // Разрешаем ввод дробных количеств. Шаг 0.1 обеспечивает ввод
          // нецелых значений, но пользователь может ввести любое число вручную.
          input.step = '0.1';
          input.value = '0';
          const plusBtn = document.createElement('button');
          plusBtn.type = 'button';
          plusBtn.textContent = '+';
          // Кнопка «Поровну»
          const equalBtn = document.createElement('button');
          equalBtn.type = 'button';
          equalBtn.textContent = 'Поровну';
          equalBtn.className = 'equal-btn';
          function updateSelection(val) {
            if (val > 0) {
              selectedQuantities[idx] = val;
              el.classList.add('selected');
            } else {
              delete selectedQuantities[idx];
              el.classList.remove('selected');
            }
          }
          minusBtn.addEventListener('click', (ev) => {
            ev.stopPropagation();
            // если выбрана поровну, не изменяем количество
            if (equalSelections[idx]) return;
            let val = parseFloat(input.value) || 0;
            if (val > 0) {
              val = val - 1;
              if (val < 0) val = 0;
              // Округляем до двух знаков для предотвращения длинных хвостов
              val = Math.round(val * 100) / 100;
              input.value = String(val);
              updateSelection(val);
              updateSummary(selectedQuantities, positions, summaryEl);
            }
          });
          plusBtn.addEventListener('click', (ev) => {
            ev.stopPropagation();
            if (equalSelections[idx]) return;
            let val = parseFloat(input.value) || 0;
            if (val < maxQty) {
              val = val + 1;
              if (val > maxQty) val = maxQty;
              val = Math.round(val * 100) / 100;
              input.value = String(val);
              updateSelection(val);
              updateSummary(selectedQuantities, positions, summaryEl);
            }
          });
          input.addEventListener('input', () => {
            if (equalSelections[idx]) return;
            let val = parseFloat(input.value) || 0;
            if (val < 0) val = 0;
            if (val > maxQty) val = maxQty;
            // Округляем ввод до двух знаков после запятой
            val = Math.round(val * 100) / 100;
            input.value = String(val);
            updateSelection(val);
            updateSummary(selectedQuantities, positions, summaryEl);
          });
          el.addEventListener('click', (ev) => {
            if (ev.target === minusBtn || ev.target === plusBtn || ev.target === input) {
              return;
            }
            // Если выбрана поровну, не изменяем количество по клику
            if (equalSelections[idx]) return;
            let val = parseFloat(input.value) || 0;
            if (val < maxQty) {
              val = val + 1;
              if (val > maxQty) val = maxQty;
              val = Math.round(val * 100) / 100;
              input.value = String(val);
              updateSelection(val);
              updateSummary(selectedQuantities, positions, summaryEl);
            }
          });
          controls.appendChild(minusBtn);
          controls.appendChild(input);
          controls.appendChild(plusBtn);
          controls.appendChild(equalBtn);
          el.appendChild(controls);
          listEl.appendChild(el);

          // Обработчик нажатия на кнопку «Поровну»
          equalBtn.addEventListener('click', (ev) => {
            ev.stopPropagation();
            if (equalSelections[idx]) {
              // Отменяем отметку «поровну»
              delete equalSelections[idx];
              equalBtn.classList.remove('active');
              el.classList.remove('equal-share');
              // Включаем поле ввода и кнопки
              input.disabled = false;
              minusBtn.disabled = false;
              plusBtn.disabled = false;
              // Сбрасываем выбранное количество, если оно было скрыто
              input.value = '0';
              delete selectedQuantities[idx];
              updateSummary(selectedQuantities, positions, summaryEl);
            } else {
              // Ставим отметку «поровну»
              equalSelections[idx] = true;
              equalBtn.classList.add('active');
              el.classList.add('equal-share');
              // Отключаем ручное изменение количества
              input.disabled = true;
              minusBtn.disabled = true;
              plusBtn.disabled = true;
              // Сбрасываем ручной выбор, если был
              input.value = '0';
              delete selectedQuantities[idx];
              updateSummary(selectedQuantities, positions, summaryEl);
            }
          });
        });
        // Инициализируем отображение
        updateSummary(selectedQuantities, positions, summaryEl);
        // Отправляем данные обратно в бота
        document.getElementById('submit').addEventListener('click', () => {
          // Формируем объект выбранных позиций: index → quantity
          const payload = {};
          Object.keys(selectedQuantities).forEach((idx) => {
            const qty = parseFloat(selectedQuantities[idx]) || 0;
            if (qty > 0) {
              payload[idx] = qty;
            }
          });
          // Формируем список индексов для деления поровну
          const equalList = Object.keys(equalSelections).map((k) => parseInt(k));
          const groupId = extractGroupId();
          const userId = (tg.initDataUnsafe && tg.initDataUnsafe.user && tg.initDataUnsafe.user.id) || null;
          // Подготовим данные для отправки
          // Базовые данные, которые отправим: выбор и group_id
          const data = { selected: payload };
          if (equalList.length > 0) {
            data.equal = equalList;
          }
          if (groupId) {
            data.group_id = groupId;
          }
          /*
           * Отправляем выбранные позиции. Если mini‑приложение запущено через клавиатурную
           * кнопку (reply‑keyboard), Telegram позволяет использовать WebApp.sendData(),
           * и бот получит сообщение с web_app_data. Для deep‑link (startapp=...) такая
           * возможность отсутствует, поэтому данные нужно отправлять напрямую на
           * backend-сервер. Проверяем наличие start_param: если он присутствует,
           * отправляем JSON через fetch; иначе используем sendData.
           */
          const hasStartParam = tg.initDataUnsafe && tg.initDataUnsafe.start_param;
          const chatType = tg.initDataUnsafe && tg.initDataUnsafe.chat_type;
          // Мини‑приложение, запущенное по ссылке (start_param или chat_type group/supergroup)
          const useBackend = hasStartParam || (chatType && chatType !== 'private');
          if (useBackend) {
            // Подписываем запрос с помощью initData для последующей валидации на сервере
            const authString = tg.initData || '';
            const payloadBody = { ...data, _auth: authString };
            // Определяем URL для отправки: используем глобальную переменную BACKEND_URL,
            // если она определена (вставляется сервером через render_receipt_page). Иначе
            // падёмся на относительный путь (когда страница загружена с backend'а напрямую).
            const submitUrl = (typeof BACKEND_URL !== 'undefined' && BACKEND_URL)
              ? `${BACKEND_URL}/webapp/api/submit`
              : '/webapp/api/submit';
            fetch(submitUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payloadBody),
            })
              .catch((err) => {
                console.error('Error submitting selection', err);
              })
              .finally(() => {
                tg.close();
              });
          } else {
            // Стандартный механизм через sendData — бот получит web_app_data
            tg.sendData(JSON.stringify(data));
            tg.close();
          }
        });
      })();
    </script>
  </body>
</html>